# Execution (пайплайны, stdio, внешние процессы, exit)

## Основные абстракции выполнения

### `Io` (потоки ввода/вывода)

Концептуально стадии пайплайна читают `stdin` и пишут в `stdout`, а диагностику пишут в `stderr`.

Практическая реализация в этом проекте:
- `stdout` стадий соединяется через OS-pipe (см. ниже);
- `stderr` стадий собирается отдельно и печатается детерминированно (в порядке команд), чтобы тесты не зависели от межпоточного интерливинга.

### `Executable` (единый интерфейс стадии)

Стадия пайплайна после планирования — это:
- `BuiltinStage { builtin, argv, env_view }`
- `ExternalStage { program, argv, env_view }`

Обе реализуют единый интерфейс исполнения (формально — trait, концептуально — контракт):
- `run(io, shell_state) -> ExitStatus`

## Построение и запуск пайплайна

Вход: `ExpandedPipeline` (argv уже `Vec<String>`), `ShellState { env, cwd, ... }`.

Алгоритм `Executor::run_pipeline(stages)`:

1. Если стадий 0 → ничего не делать.
2. Если стадия 1:
   - выполнить её напрямую (без pipe), вернуть её статус.
3. Если стадий \(N ≥ 2\):
   - создать \(N-1\) соединений pipe: `pipe[i]` соединяет `stage[i].stdout -> stage[i+1].stdin`.
   - запустить стадии так, чтобы они могли **работать параллельно**, иначе возможны deadlock/заполнение буфера.

### Реализация pipe (выбор фиксируем)

Так как в `std` нет кроссплатформенного `pipe()` для произвольных `Read/Write`, в реализации используется crate `os_pipe`.

- На всех платформах создаём OS-pipe через `os_pipe::pipe()`.
- Для external стадий подключаем концы pipe напрямую через `std::process::Stdio::from(reader/writer)`.
- Для последней стадии stdout собираем через отдельный pipe в родителе (REPL читает из него и пишет в свой `stdout`).

## External programs (`std::process::Command`)

Для `ExternalStage`:
- создаём `std::process::Command(program)`
- выставляем `.args(argv[1..])`
- **окружение процесса**: наследуем окружение родительского процесса (чтобы работал `PATH` и базовые переменные),
  затем применяем overlay из shell‑окружения/временных присваиваний: `.envs(env_view)`
- выставляем `.current_dir(shell_state.cwd)`
- подключаем stdin/stdout/stderr через `Stdio` (в пайплайне — piped/перенаправленные концы).

Источник по pipe‑взаимодействию процесса: `https://doc.rust-lang.org/rust-by-example/std_misc/process/pipe.html`

## Builtins как стадии пайплайна

Builtins работают **внутри** процесса интерпретатора, но должны уметь:
- читать из `stdin` (например `wc` без файла; `cat` без файла),
- писать в `stdout` (для пайплайна),
- писать ошибки в `stderr`,
- возвращать `ExitStatus`.

Если builtin стоит внутри пайплайна, он запускается в отдельном потоке (thread), чтобы:
- upstream мог писать, пока downstream читает,
- избежать блокировок при заполнении буфера.

Примечание по stdin первой стадии: так как REPL читает команды из своего input-потока построчно, stdin первой стадии пайплайна сейчас задаётся как `null` (до появления редиректов), чтобы не смешивать ввод REPL и ввод команды.

## Семантика `exit`

`exit` — builtin, который завершает REPL.

Фиксируем правило (чтобы не было двусмысленности):
- `exit` разрешён **только как единственная команда строки** (pipeline длины 1, без `|`).
- `exit` внутри пайплайна — синтаксическая/семантическая ошибка (возвращаем код 2 и продолжаем REPL).

## Поведение встроенных команд (минимально необходимое)

- `echo [args...]`:
  - печатает args, разделяя пробелом, без переноса строки (так сформулированно в задании, в обычном shell \n печатается).
- `pwd`:
  - печатает `ShellState.cwd` + `\n`.
- `cat [file]`:
  - если file задан: печатает содержимое файла;
  - иначе: копирует `stdin -> stdout`.
- `wc [file]`:
  - если file задан: считает по файлу;
  - иначе: считает по `stdin`;
  - вывод: `lines words bytes` (как в примерах).
- `grep [-w] [-i] [-A N] <pattern> [file ...]`:
  - ищет строки, матчащиеся по регулярному выражению `pattern`;
  - если заданы `file ...`: читает последовательно каждый файл;
    - если файлов больше одного, печатает строки с префиксом `file:` (как минимальная форма различения источника);
  - если файлы не заданы: читает из `stdin` (актуально для пайпов);
  - `-i`: регистронезависимый матч;
  - `-w`: матч только целого слова (границы слова по `is_alphanumeric` и `_`);
  - `-A N`: печатает N строк после совпадения (пересечения контекстов не дублируются).

## Коды возврата и ошибки

- Ошибка парсинга/незакрытые кавычки/`|` без команды: статус 2, диагностика в `stderr`.
- Ошибка запуска external (не найдено): статус 127 (по традиции), диагностика в `stderr`.
- Ошибка открытия файла в builtin: статус 1, диагностика в `stderr`.

> Ключевой момент из чеклиста: **аргументы и входной поток — разные вещи**. Например, `echo 123 | wc` передаёт “123” через stdin, а не как argv.
