# Execution (пайплайны, stdio, внешние процессы, exit)

## Основные абстракции выполнения

### `Io` (потоки ввода/вывода)

Чтобы builtin и external стадии выглядели одинаково для пайплайна, вводится абстракция:

- `stdin: Box<dyn Read + Send>`
- `stdout: Box<dyn Write + Send>`
- `stderr: Box<dyn Write + Send>`

REPL создаёт “терминальные” `Io` (реальные stdin/stdout/stderr), а `Executor` для пайплайна подменяет `stdin/stdout` стадий на концы pipe.

### `Executable` (единый интерфейс стадии)

Стадия пайплайна после планирования — это:
- `BuiltinStage { builtin, argv, env_view }`
- `ExternalStage { program, argv, env_view }`

Обе реализуют единый интерфейс исполнения (формально — trait, концептуально — контракт):
- `run(io, shell_state) -> ExitStatus`

## Построение и запуск пайплайна

Вход: `ExpandedPipeline` (argv уже `Vec<String>`), `ShellState { env, cwd, ... }`.

Алгоритм `Executor::run_pipeline(stages)`:

1. Если стадий 0 → ничего не делать.
2. Если стадия 1:
   - выполнить её напрямую (без pipe), вернуть её статус.
3. Если стадий \(N ≥ 2\):
   - создать \(N-1\) соединений pipe: `pipe[i]` соединяет `stage[i].stdout -> stage[i+1].stdin`.
   - запустить стадии так, чтобы они могли **работать параллельно**, иначе возможны deadlock/заполнение буфера.

### Реализация pipe (выбор фиксируем)

Так как в `std` нет кроссплатформенного “аналогичного `pipe()`” для произвольных `Read/Write`, в реализации планируется:
- на Unix: использовать OS pipe через небольшой crate (`os_pipe` или `nix`) и оборачивать концы в `Read/Write`;
- на Windows: аналогично через crate (или использовать стратегию “в памяти” только если потребуется).

Важно: интерфейс `Executor` **не зависит** от конкретного backend pipe.

## External programs (`std::process::Command`)

Для `ExternalStage`:
- создаём `std::process::Command(program)`
- выставляем `.args(argv[1..])`
- **окружение процесса**: наследуем окружение родительского процесса (чтобы работал `PATH` и базовые переменные),
  затем применяем overlay из shell‑окружения/временных присваиваний: `.envs(env_view)`
- выставляем `.current_dir(shell_state.cwd)`
- подключаем stdin/stdout/stderr через `Stdio` (в пайплайне — piped/перенаправленные концы).

Источник по pipe‑взаимодействию процесса: `https://doc.rust-lang.org/rust-by-example/std_misc/process/pipe.html`

## Builtins как стадии пайплайна

Builtins работают **внутри** процесса интерпретатора, но должны уметь:
- читать из `stdin` (например `wc` без файла; `cat` без файла),
- писать в `stdout` (для пайплайна),
- писать ошибки в `stderr`,
- возвращать `ExitStatus`.

Если builtin стоит внутри пайплайна, он запускается в отдельном потоке (thread), чтобы:
- upstream мог писать, пока downstream читает,
- избежать блокировок при заполнении буфера.

## Семантика `exit`

`exit` — builtin, который завершает REPL.

Фиксируем правило (чтобы не было двусмысленности):
- `exit` разрешён **только как единственная команда строки** (pipeline длины 1, без `|`).
- `exit` внутри пайплайна — синтаксическая/семантическая ошибка (возвращаем код 2 и продолжаем REPL).

## Поведение встроенных команд (минимально необходимое)

- `echo [args...]`:
  - печатает args, разделяя пробелом, без переноса строки (так сформулированно в задании, в обычном shell \n печатается).
- `pwd`:
  - печатает `ShellState.cwd` + `\n`.
- `cat [file]`:
  - если file задан: печатает содержимое файла;
  - иначе: копирует `stdin -> stdout`.
- `wc [file]`:
  - если file задан: считает по файлу;
  - иначе: считает по `stdin`;
  - вывод: `lines words bytes` (как в примерах).

## Коды возврата и ошибки

- Ошибка парсинга/незакрытые кавычки/`|` без команды: статус 2, диагностика в `stderr`.
- Ошибка запуска external (не найдено): статус 127 (по традиции), диагностика в `stderr`.
- Ошибка открытия файла в builtin: статус 1, диагностика в `stderr`.

> Ключевой момент из чеклиста: **аргументы и входной поток — разные вещи**. Например, `echo 123 | wc` передаёт “123” через stdin, а не как argv.
