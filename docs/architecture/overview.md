# Overview: модули и расширяемость

## Основные сущности (объектная модель)

Порядок стадий такой:

1) `Expander` выполняет `$NAME` в сырой строке
2) `Lexer` режет на слова и `|` с учётом кавычек
3) `Parser` строит `PipelineAst`

Основные структуры:

- **`Token`**: `Word(String)` или `Pipe`
- **`PipelineAst`**: список стадий пайплайна, каждая стадия — `SimpleCommandAst`
- **`SimpleCommandAst`**:
  - `assignments: Vec<AssignmentAst>` — ведущие `NAME=value` перед командой
  - `argv: Vec<String>` — имя команды и аргументы (после expand + quote removal)

Принцип: **пайпы и пробелы — структурные только вне кавычек**, а внутри кавычек входят в литерал.

## Компоненты и интерфейсы (Rust модули)

Предлагаемая модульная структура (без реализации деталей на этом этапе):

- `repl/` — чтение строк, цикл, печать ошибок
- `expand/` — `Expander` применяет `$NAME` к строке, возвращает новую строку
- `lex/` — `Lexer` → `Vec<Token>` (quote-aware, делает quote removal)
- `parse/` — `Parser` → `PipelineAst`
- `env/` — `EnvStore` (shell vars) + “temporary overlay” для `NAME=value cmd`
- `exec/` — `Executor` (пайпы, запуск стадий)
- `builtins/` — реализации встроенных команд + `BuiltinRegistry`
- `external/` — адаптер к `std::process::Command`

## Как “легко добавлять новые команды”

**Встроенная команда** добавляется без изменения парсера/лексера:
1. Создать тип `FooBuiltin`, реализующий интерфейс:
   - `name() -> &'static str`
   - `run(args, io, ctx) -> ExitStatus`
2. Зарегистрировать в `BuiltinRegistry` (например, `HashMap<String, Arc<dyn Builtin>>`).

Важное: `run` работает с **потоками**, а не с “входными аргументами как текстом”. Аргументы (`argv`) и входной поток (`stdin`) — разные вещи.

## Коды возврата

- Каждый builtin возвращает `ExitStatus(u8)` (0 — успех, ненулевые — ошибка).
- Для external код берём из `ExitStatus` процесса (или маппим сигналы/ошибки запуска в фиксированные коды).
- Итоговый статус строки — статус **последней стадии пайплайна** (как в большинстве shell’ов).
