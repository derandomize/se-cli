# Parsing & Expansion (кавычки, `$`, присваивания, `|`)

Цель этого документа: описать **конкретный** пайплайн преобразования строки, чтобы при реализации не принимать спорных решений.

## 1) Expander ДО токенизации

Фиксируем порядок стадий так:

1) **expander** выполняет подстановки `$NAME` в исходной строке;
2) затем **lexer** режет строку на слова/пайпы с учётом кавычек.

Это нужно, чтобы корректно работали случаи, где после подстановки образуется имя команды без пробелов:

```text
x=ex y=it
$x$y    -> после подстановки получаем "exit", затем токенизируем
```

Вход: `&str` (одна строка без `\n`) + `EnvStore`.  
Выход: новая строка `String`.

### Правила расширения

- Подстановка выполняется **только** для `$NAME`, где `NAME = [A-Za-z_][A-Za-z0-9_]*`.
- В одинарных кавычках `'...'` подстановок нет: `$` трактуется как обычный символ.
- В двойных кавычках `"..."` подстановка есть.
- Вне кавычек подстановка есть.
- Если переменной нет — подставляем пустую строку.
- Кавычки expander **не удаляет**: они остаются в выходной строке, чтобы lexer потом мог корректно сгруппировать аргументы.

> Замечание про “word splitting”: поскольку токенизация выполняется после подстановки, пробелы, появившиеся из значения переменной **вне кавычек**, будут разделять аргументы. Внутри `"..."` пробелы остаются частью одного аргумента.

## 2) Лексер (tokenizer) с учётом кавычек

Вход: `&str` (уже после expand).  
Выход: `Vec<Token>`, где `Token = Word(String) | Pipe`.

### Правила распознавания

- **Whitespace** (`' '`, `\t`) разделяет слова **только когда мы вне кавычек**.
- Символ `|` — отдельный токен `Pipe` **только когда мы вне кавычек**.
- Одинарные кавычки `'`:
  - открывают/закрывают режим `SingleQuoted`;
  - внутри всё — литерал (включая `$`, `|`, пробелы).
- Двойные кавычки `"`:
  - открывают/закрывают режим `DoubleQuoted`;
  - внутри пробелы — литерал, `|` — литерал;
  - `$NAME` остаётся “особым” (см. ниже).
- Если кавычка не закрыта до конца строки — **синтаксическая ошибка**.

### Quote removal

Lexer воспринимает кавычки как синтаксис и **не включает** их в итоговый `Word(String)`. То есть:

- `echo "a b"` даёт один аргумент `"a b"` (без кавычек);
- `echo 'a b'` даёт один аргумент `"a b"` (без кавычек).

## 3) Парсер (Pipeline AST)

Вход: `Vec<Token>`.  
Выход: `PipelineAst { commands: Vec<SimpleCommandAst> }`.

Грамматика (упрощённо):

```
pipeline := command ('|' command)*
command  := (assignment)* argv
assignment := WORD_WITH_EQUAL_SIGN
argv := word+
```

### Разбор присваиваний

Токен `Word` считается `assignment`, если слово начинается с `NAME=` и `NAME` удовлетворяет правилу имени: `[A-Za-z_][A-Za-z0-9_]*`.

Уточнение: `=` внутри кавычек не делает слово присваиванием, но поскольку lexer удаляет кавычки, для точного различения в реализации может понадобиться хранить метаданные “какая часть слова была в кавычках”. Это решение оставляем на этап реализации.

Тогда:
- `AssignmentAst { name: String, value: String }` (значение уже после expand; кавычки сняты токенизацией).

Команда может быть:
- **“только присваивания”**: `assignments > 0`, `argv.is_empty()` → это команда‑оператор изменения окружения;
- **присваивания + argv**: `assignments > 0`, `argv.len() >= 1` → временное окружение для запуска.

## 4) Встроенное состояние окружения

`EnvStore` хранит пары `String -> String` и поддерживает:
- `set(name, value)`
- `get(name)`
- `overlay(temp_assignments)` → временный “вид” окружения для конкретной команды (не меняет базу).

Присваивания “как отдельная команда” (`x=1 y=2`) применяются к **базовому** `EnvStore` после успешного парсинга строки.

### Порядок вычисления нескольких присваиваний (фиксируем)

Если в одной строке несколько присваиваний, они обрабатываются **слева направо**.

- При обработке строки допускается, что значения присваиваний могут ссылаться на уже определённые переменные (включая предыдущие присваивания этой же строки):

Пример: `x=1 y=$x` задаёт `y="1"`.

## Источник (1)

- Bash Reference Manual — Quoting: `https://www.gnu.org/software/bash/manual/html_node/Quoting.html`
