# Parsing & Expansion (кавычки, `$`, присваивания, `|`)

Цель этого документа: описать **конкретный** пайплайн преобразования строки, чтобы при реализации не принимать спорных решений.

## 1) Лексер (tokenizer) с учётом кавычек

Вход: `&str` (одна строка без `\n`).  
Выход: `Vec<Token>`, где `Token = Word(WordAst) | Pipe`.

### Правила распознавания

- **Whitespace** (`' '`, `\t`) разделяет слова **только когда мы вне кавычек**.
- Символ `|` — отдельный токен `Pipe` **только когда мы вне кавычек**.
- Одинарные кавычки `'`:
  - открывают/закрывают режим `SingleQuoted`;
  - внутри всё — литерал (включая `$`, `|`, пробелы).
- Двойные кавычки `"`:
  - открывают/закрывают режим `DoubleQuoted`;
  - внутри пробелы — литерал, `|` — литерал;
  - `$NAME` остаётся “особым” (см. ниже).
- Если кавычка не закрыта до конца строки — **синтаксическая ошибка**.

### Как формируется `WordAst`

`WordAst` строится как список `parts` (это важно для `$x$y`):

- При накоплении текста в текущем режиме создаём `Literal { text, quoting }`.
- При встрече `$`:
  - если `quoting == SingleQuoted` → добавляем литерал `"$"` (ничего не расширяем);
  - если `quoting == Unquoted` или `DoubleQuoted` → пытаемся распознать имя переменной:
    - `NAME = [A-Za-z_][A-Za-z0-9_]*`
    - если имя пустое (например `$` в конце) — трактуем `$` как литерал.
    - иначе добавляем `Var { name, quoting }`.

> Так “подстановка” представлена **до финальной токенизации в argv**: мы уже знаем, где `$` и где литерал, но ещё не сделали замену.

## 2) Парсер (Pipeline AST)

Вход: `Vec<Token>`.  
Выход: `PipelineAst { commands: Vec<SimpleCommandAst> }`.

Грамматика (упрощённо):

```
pipeline := command ('|' command)*
command  := (assignment)* argv
assignment := WORD_WITH_EQUAL_SIGN
argv := word+
```

### Разбор присваиваний

Токен `Word` считается `assignment`, если:
- слово **начинается** с префикса `NAME=` **вне кавычек** (то есть `NAME=` приходит из `Literal{..., quoting=Unquoted}`),
- `NAME` удовлетворяет правилу имени: `[A-Za-z_][A-Za-z0-9_]*`.

Уточнение: `=` внутри кавычек не делает слово присваиванием (например, `echo "a=b"` — обычный аргумент).

Тогда:
- `AssignmentAst { name: String, value: WordAst }`, где `value` — `WordAst`, полученный разбором части **после** `=`
  - (то есть value тоже может содержать кавычки и `$`).

Команда может быть:
- **“только присваивания”**: `assignments > 0`, `argv.is_empty()` → это команда‑оператор изменения окружения;
- **присваивания + argv**: `assignments > 0`, `argv.len() >= 1` → временное окружение для запуска.

## 3) Expander (окружение + quote removal)

Вход: `PipelineAst` + `EnvStore`.  
Выход: `ExpandedPipeline`, где все `WordAst` превращены в `String` (argv готов к выполнению).

### Алгоритм расширения одного слова

`expand_word(word: WordAst) -> String`:
- для каждого `part` слева направо:
  - `Literal(text, _)` → добавляем `text`;
  - `Var(name, quoting)`:
    - если `quoting == SingleQuoted`: (на практике не бывает, мы не создаём `Var` в single quotes)
    - иначе подставляем `EnvStore.get(name).unwrap_or("")`.
- “Quote removal”: поскольку кавычки не хранятся в `Literal`, дополнительных действий не требуется (кавычки уже “съедены” лексером как синтаксис).

### Важное упрощение (фиксируем)

- **Нет word splitting** по результатам `$NAME` (в отличие от POSIX shell).  
  То есть если `A="1 2"` и написать `echo $A`, мы передадим один аргумент `"1 2"`.  
  Это сильно упрощает реализацию и делает поведение стабильным для учебного проекта.

## 4) Встроенное состояние окружения

`EnvStore` хранит пары `String -> String` и поддерживает:
- `set(name, value)`
- `get(name)`
- `overlay(temp_assignments)` → временный “вид” окружения для конкретной команды (не меняет базу).

Присваивания “как отдельная команда” (`x=1 y=2`) применяются к **базовому** `EnvStore` после успешного парсинга/расширения RHS.

### Порядок вычисления нескольких присваиваний (фиксируем)

Если в одной строке несколько присваиваний, они обрабатываются **слева направо**.

- При расширении RHS очередного присваивания используется “вид” окружения, который включает:
  - базовый `EnvStore`,
  - **все предыдущие присваивания этой же команды/строки** (как overlay).

Пример: `x=1 y=$x` задаёт `y="1"`.

## Источник (1)

- Bash Reference Manual — Quoting: `https://www.gnu.org/software/bash/manual/html_node/Quoting.html`
